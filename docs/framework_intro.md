# Introduction

Every microservice in the Godspeed framework has three fundamental abstractions, and the developer needs to work with just these three.

## Guiding principles of design

### Three fundamental abstractions
Every microservice in the Godspeed framework has three fundamental abstractions, and the developer needs to work with just these three.

- **Events**: Events trigger workflows. Events are generated by event sources like REST endpoints, gRPC, message bus, webhooks, websockets, S3, and more...

- **Workflows**: Workflows are triggered by events. They not only perform business logic but also provide orchestration over datasources and microservices, and data/API federation. They will use datasources to store or retrieve data, join across various datasources, transform data, emit events and send responses. The framework provides a YAML dsl with some inbuilt workflows. If YAML does not suffice for any particular case, developers can currently put JS/TS workflows alongside YAML workflows and use them. Coming in future: Support for other languages.

- **Datasources**: Datasources are locations where data can be stored or read from. For example API datasource (another microservice or third party), datastores (RDBMS, document, key-value), file system, S3 storage, etc. A microservice can use multiple datasources. The framework provides abstractions for Authn/Authz making it easy for the developer to express the same in a low code manner.

## Building blocks of framework:

1. [**Events:**](/docs/events/overview.md) Events of async and sync kind, Define endpoint, input, and response.
2. [**Workflows:**](/docs/workflows/overview.md) Handler of events. Your business logic goes here.
3. [**EventSources:**](/docs/event_sources/overview.md) Pluggable event sources of different kinds like, **express, Kafka, salesforce**
4. [**DataSources:**](/docs/data_sources/overview.md) Pluggable data source to store and retrieve data like **Mongo, Redis, API**
5. [**Config:**](#building-blocks-of-framework) Application-level configuration.
6. [**ENV:**](#building-blocks-of-framework) environment files.
7. [**DSL**](#building-blocks-of-framework): As the default, events and workflows are composed using YAML-based DSL, which serves as the primary language for defining them. However, when necessary, workflows can also be scripted in JavaScript files.

YAML-based **DSL (Domain-Specific Language)** is a concise and human-readable way to define and configure data and processes. It simplifies complex structures using indentation and key-value pairs, making it an efficient choice for expressing data, workflows, and configurations.


## Developer's work 
The developer will utilize the framework's CLI to initiate a new microservice project and begin development. They will set up the necessary events, data sources, workflows, and configurations such as mappings, environment variables, and telemetry settings. When configuring data sources:
- For databases, they can either define the database schema or auto-generate it from the existing database using the CLI.
- For APIs, they should specify the OpenAPI schema or provide the corresponding URL.


### Salient Features

:::tip Note
Some of the features mentioned here are in the product roadmap and planned for upcoming releases.
:::

**Schema driven development**

To initiate development, the developer needs to define the API and data schema.

**YAML based DSL and configurations**

Our YAML-based DSL simplifies the expression of policies, business logic, and configurations. It results in shorter and more comprehensible code compared to traditional programming, even for beginners. Developers can further customize this DSL to accommodate specific requirements.

**Multi datastore support**

The model configuration and unified CRUD API, which includes full-text search and autosuggest, offer interfaces to various types of datastores, whether SQL or NoSQL. This API is designed to handle validation, relationship management, transactions, denormalization, and multilingual support. Each integration adapts to the specific functionality required based on the nature of the data store.  


**Data validation**

The framework offers validation for third-party API requests and responses, datastore queries, and its own API endpoints. Developers are only required to define the schema for third-party APIs, their microservice APIs, and datastore models. The framework handles the rest. For more intricate validation scenarios, such as conditional validation based on attributes like subject, object, environment, or payload, developers can incorporate these rules into the application logic as part of the workflows.

**Authentication**

The microservice framework performs authentication on all incoming requests, extracting user roles and additional information from a valid JWT token for further processing. The platform allows integration with an IAM provider like ORY Kratos to provide identity services. This IAM provider generates a JWT token containing user ID, user information, and roles, which is utilized by the microservices to validate users.

**Authorization** **(**<Highlight color="#D0F9E5">Planned</Highlight>**)**

Each microservice handles the authorization process for incoming requests. Developers will define authorization rules for each microservice using straightforward configuration files. These rules encompass not only access to API endpoints but also provide fine-grained data access within datastores. The framework allows seamless integration with third-party authorization services through flexible abstractions.

**Distributed transactions** **(**<Highlight color="#D0F9E5">Planned</Highlight>**)**

Each domainâ€™s orchestrator is able to use the Saga [pattern](https://www.baeldung.com/cs/saga-pattern-microservices) to ensure distributed transactions across multiple microservices.


**Autogenerated documentation**

The framework provides autogenerated documentation using CLI.

**Autogenerated CRUD API**  **(**<Highlight color="#D0F9E5">Planned</Highlight>**)**

The framework provides autogenereated CRUD APIs from database model. Generated API's can be extended by the developers as per their needs.


**Multiple languages support**

If YAML isn't sufficient to address a specific scenario, developers have the flexibility to create custom business logic in their language of choice. If they opt for JavaScript or TypeScript, they can conveniently include the code within the same microservice project. Support for other languages will follow the same approach and is part of our future plans.